import typer
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.live import Live
from rich.markdown import Markdown
from rich.syntax import Syntax
from rich.table import Table
from rich import box
from typing import Optional
import httpx
import json
import asyncio
import time
import re
import os
from pydantic import BaseModel
from .prompts import format_prompt
from datetime import datetime

app = typer.Typer(
    name="dockerfile-ai",
    help="AI-powered Dockerfile analyzer and fixer using Ollama",
    add_completion=False,
)
console = Console()

class OllamaResponse(BaseModel):
    response: str
    done: bool

def read_dockerfile(file_path: Path) -> str:
    """Read and return the contents of a Dockerfile."""
    try:
        return file_path.read_text()
    except Exception as e:
        console.print(f"[red]Error reading Dockerfile: {str(e)}[/red]")
        raise typer.Exit(1)

def extract_dockerfile_content(text: str) -> str:
    """Extract the Dockerfile content from the analysis text.
    Expects the Dockerfile to be in a triple-quoted code block.
    """
    # Look for triple-quoted Dockerfile code block
    pattern = r'```(?:dockerfile|Dockerfile)?\n(.*?)```'
    match = re.search(pattern, text, re.DOTALL)
    
    if match:
        content = match.group(1).strip()
        # Basic validation
        if content and content.startswith('FROM'):
            return content
    
    return ""

async def query_ollama(dockerfile_content: str, model: str) -> str:
    """Query Ollama API with the Dockerfile content."""
    prompt = format_prompt(dockerfile_content)

    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                "http://localhost:11434/api/generate",
                json={
                    "model": model,
                    "prompt": prompt,
                    "temperature": 0.7,
                    "top_p": 0.9,
                    "max_tokens": 4000
                },
                timeout=120.0
            )
            response.raise_for_status()
            
            # Handle streaming response
            full_response = ""
            for line in response.text.strip().split('\n'):
                if line.strip():
                    try:
                        data = json.loads(line)
                        if 'response' in data:
                            full_response += data['response']
                        if data.get('done', False):
                            break
                    except json.JSONDecodeError:
                        continue
            
            if not full_response.strip():
                raise ValueError("Empty response from Ollama")
            
            return full_response.strip()
            
        except httpx.RequestError as e:
            console.print(f"[red]Error connecting to Ollama: {str(e)}[/red]")
            raise typer.Exit(1)
        except ValueError as e:
            console.print(f"[red]Error in Ollama response: {str(e)}[/red]")
            raise typer.Exit(1)
        except Exception as e:
            console.print(f"[red]Unexpected error: {str(e)}[/red]")
            raise typer.Exit(1)

def create_header() -> Panel:
    """Create a fancy header panel."""
    table = Table.grid(padding=1)
    table.add_column(style="cyan", justify="center")
    table.add_row("ü§ñ Dockerfile AI Analyzer")
    table.add_row("üîç Analyzing your Dockerfile with AI...")
    return Panel(table, border_style="cyan", box=box.ROUNDED)

def create_warning() -> Panel:
    """Create a warning panel about AI output."""
    warning_text = """‚ö†Ô∏è  [bold yellow]Important Notice:[/bold yellow]
This analysis is generated by AI and should be reviewed carefully before implementation.
Always verify security implications and test changes in a safe environment.
The suggestions provided are not guaranteed to be perfect or secure for all use cases."""
    
    return Panel(
        warning_text,
        title="[bold yellow]‚ö†Ô∏è  AI Output Warning[/bold yellow]",
        border_style="yellow",
        box=box.ROUNDED,
        padding=(1, 2)
    )

def display_typewriter(text: str, speed: float = 0.001, copyable: bool = False):
    """Display text with a typewriter effect."""
    with Live(console=console, refresh_per_second=30) as live:
        if copyable:
            # For copyable version, just print the Dockerfile content
            dockerfile_content = extract_dockerfile_content(text)
            if dockerfile_content:
                live.update(dockerfile_content)
            return

        # Apply typewriter effect to the raw text
        current_text = ""
        buffer = ""
        last_update = time.time()
        update_interval = 0.05  # Update every 50ms
        
        for char in text:
            current_text += char
            buffer += char
            time.sleep(speed)
            
            # Only update the display periodically to prevent lag
            current_time = time.time()
            if current_time - last_update >= update_interval:
                try:
                    # Create a new markdown and panel for the current text
                    current_markdown = Markdown(current_text)
                    current_panel = Panel(
                        current_markdown,
                        title="[bold cyan]‚ú® Analysis Results[/bold cyan]",
                        border_style="cyan",
                        box=box.ROUNDED,
                        width=console.width - 4,
                        padding=(1, 2)
                    )
                    live.update(current_panel)
                except Exception:
                    # If markdown parsing fails, just show the raw text
                    live.update(current_text)
                
                buffer = ""
                last_update = current_time
        
        # Final update to ensure all content is displayed
        if buffer:
            try:
                current_markdown = Markdown(current_text)
                current_panel = Panel(
                    current_markdown,
                    title="[bold cyan]‚ú® Analysis Results[/bold cyan]",
                    border_style="cyan",
                    box=box.ROUNDED,
                    width=console.width - 4,
                    padding=(1, 2)
                )
                live.update(current_panel)
            except Exception:
                live.update(current_text)

def get_output_dir() -> Path:
    """Get the path to the output directory."""
    # Get the package root directory
    package_root = Path(__file__).parent.parent.parent
    return package_root / "output"

def ensure_output_dirs() -> tuple[Path, Path]:
    """Ensure output directories exist and return their paths.
    
    Returns:
        Tuple of (analysis_dir, dockerfiles_dir) paths
    """
    output_dir = get_output_dir()
    analysis_dir = output_dir / "analysis"
    dockerfiles_dir = output_dir / "dockerfiles"
    
    # Create directories if they don't exist
    analysis_dir.mkdir(parents=True, exist_ok=True)
    dockerfiles_dir.mkdir(parents=True, exist_ok=True)
    
    return analysis_dir, dockerfiles_dir

def save_analysis_file(analysis: str, dockerfile_name: str) -> Path:
    """Save the analysis output to a file.
    
    Args:
        analysis: The analysis text to save
        dockerfile_name: Name of the original Dockerfile
        
    Returns:
        Path to the saved analysis file
    """
    analysis_dir, _ = ensure_output_dirs()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_name = f"{Path(dockerfile_name).stem}_{timestamp}_analysis.md"
    output_path = analysis_dir / output_name
    output_path.write_text(analysis)
    return output_path

def save_dockerfile(dockerfile_content: str, dockerfile_name: str) -> Path:
    """Save the corrected Dockerfile to a file.
    
    Args:
        dockerfile_content: The corrected Dockerfile content
        dockerfile_name: Name of the original Dockerfile
        
    Returns:
        Path to the saved Dockerfile
    """
    _, dockerfiles_dir = ensure_output_dirs()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_name = f"{Path(dockerfile_name).stem}_{timestamp}_corrected.Dockerfile"
    output_path = dockerfiles_dir / output_name
    output_path.write_text(dockerfile_content)
    return output_path

@app.command()
def analyze(
    dockerfile: Path = typer.Argument(
        ...,
        help="Path to the Dockerfile to analyze",
        exists=True,
        file_okay=True,
        dir_okay=False,
        readable=True,
    ),
    output: Optional[Path] = typer.Option(
        None,
        "--output", "-o",
        help="Path to save the corrected Dockerfile (if not specified, saves to output/dockerfiles)",
        file_okay=True,
        dir_okay=False,
        writable=True,
    ),
    copy: bool = typer.Option(
        False,
        "--copy", "-c",
        help="Display only the corrected Dockerfile for easy copying",
    ),
    speed: float = typer.Option(
        0.001,
        "--speed", "-s",
        help="Speed of the typewriter effect (lower is faster)",
    ),
    model: str = typer.Option(
        os.getenv("OLLAMA_MODEL", "qwen2.5-coder:7b"),
        "--model", "-m",
        help="Ollama model to use for analysis",
    ),
    save_analysis: bool = typer.Option(
        True,
        "--save-analysis/--no-save-analysis",
        help="Whether to save the analysis output to a file",
    ),
):
    """Analyze a Dockerfile using AI and provide improvement suggestions."""
    # Print fancy header
    console.print(create_header())

    dockerfile_content = read_dockerfile(dockerfile)
    
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
        transient=True
    ) as progress:
        progress.add_task("Analyzing Dockerfile...", total=None)
        analysis = asyncio.run(query_ollama(dockerfile_content, model))

    if not copy:
        console.print("\n[bold cyan]‚ú® Analysis Results:[/bold cyan]")
    display_typewriter(analysis, speed, copy)

    if not copy:
        # Print warning after analysis
        console.print("\n")
        console.print(create_warning())

    # Save analysis if requested
    if save_analysis and not copy:
        analysis_path = save_analysis_file(analysis, dockerfile.name)
        console.print(f"\n[cyan]üìù Analysis saved to: {analysis_path}[/cyan]")


if __name__ == "__main__":
    app() 